/**
 * BadgeItem Component Tests
 * 
 * Tests the BadgeItem component which displays individual badge information
 * with animation effects for new badges and proper metadata display.
 */

import React from 'react'
import { render, waitFor } from '@testing-library/react-native'
import { Animated } from 'react-native'
import BadgeItem from '../../components/BadgeItem'

// Mock the specialBadgeService
jest.mock('../../services/specialBadgeService', () => ({
  getBadgeMetadata: jest.fn((type: string) => {
    const metadata: Record<string, any> = {
      'daily_steps': {
        type: 'daily_steps',
        name: '‰ªäÊó•„ÅÆÊ≠©Êï∞',
        description: '1Êó•„ÅÆÊ≠©Êï∞ÁõÆÊ®ô„ÇíÈÅîÊàê',
        icon: 'üëü',
        category: 'Regular',
        rarity: 'Common'
      },
      'steps_10k': {
        type: 'steps_10k',
        name: '1‰∏áÊ≠©ÈÅîÊàê',
        description: '1Êó•„Åß1‰∏áÊ≠©„ÇíÈÅîÊàê',
        icon: 'üèÉ',
        category: 'Regular',
        rarity: 'Rare'
      },
      'spring_badge': {
        type: 'spring_badge',
        name: 'Êò•„ÅÆ„Éê„ÉÉ„Ç∏',
        description: 'Êò•„Å´Áç≤Âæó„Åó„Åü„Éê„ÉÉ„Ç∏',
        icon: 'üå∏',
        category: 'Seasonal',
        rarity: 'Epic'
      }
    }
    return metadata[type] || null
  })
}))

describe('BadgeItem Component', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('Rendering and Basic Display', () => {
    test('renders badge with correct date and type', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('2023-12-01 ‰ªäÊó•„ÅÆÊ≠©Êï∞')).toBeTruthy()
    })

    test('displays correct badge icon from metadata', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('üëü')).toBeTruthy()
    })

    test('uses fallback when badge metadata is not found', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="unknown_badge" isNew={false} />
      )

      expect(getByText('2023-12-01 unknown_badge')).toBeTruthy()
      expect(getByText('üèÖ')).toBeTruthy() // fallback icon
    })

    test('displays different badges with correct metadata', () => {
      const { getByText: getText1 } = render(
        <BadgeItem date="2023-12-01" type="steps_10k" isNew={false} />
      )
      expect(getText1('üèÉ')).toBeTruthy()
      expect(getText1('2023-12-01 1‰∏áÊ≠©ÈÅîÊàê')).toBeTruthy()

      const { getByText: getText2 } = render(
        <BadgeItem date="2023-12-02" type="spring_badge" isNew={false} />
      )
      expect(getText2('üå∏')).toBeTruthy()
      expect(getText2('2023-12-02 Êò•„ÅÆ„Éê„ÉÉ„Ç∏')).toBeTruthy()
    })
  })

  describe('New Badge Display', () => {
    test('displays new badge indicator when isNew is true', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      expect(getByText('Êñ∞ÁùÄ')).toBeTruthy()
    })

    test('does not display new badge indicator when isNew is false', () => {
      const { queryByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(queryByText('Êñ∞ÁùÄ')).toBeFalsy()
    })

    test('displays star icon for new badges instead of regular icon', () => {
      const { getByText, queryByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      expect(getByText('üåü')).toBeTruthy()
      expect(queryByText('üëü')).toBeFalsy() // regular icon should not be shown
    })

    test('applies new card styling when isNew is true', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const card = getByTestId('badge-card')
      expect(card.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            backgroundColor: expect.any(String),
            borderColor: expect.any(String)
          })
        ])
      )
    })

    test('applies new text styling when isNew is true', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const text = getByTestId('badge-text')
      expect(text.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            color: expect.any(String),
            fontWeight: expect.any(String)
          })
        ])
      )
    })
  })

  describe('Animation Behavior', () => {
    test('initializes shine animation value when component mounts', () => {
      render(<BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />)

      expect(Animated.Value).toHaveBeenCalledWith(-100)
    })

    test('starts shine animation loop when badge is new', async () => {
      render(<BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />)

      await waitFor(() => {
        expect(Animated.loop).toHaveBeenCalled()
        expect(Animated.timing).toHaveBeenCalledWith(
          expect.any(Object),
          expect.objectContaining({
            toValue: 100,
            duration: 1500,
            useNativeDriver: true
          })
        )
      })
    })

    test('does not start shine animation when badge is not new', () => {
      render(<BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />)

      expect(Animated.loop).not.toHaveBeenCalled()
    })

    test('applies shine animation transform to shine view', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const shineView = getByTestId('shine-view')
      expect(shineView.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            transform: expect.arrayContaining([
              expect.objectContaining({ translateX: expect.any(Object) })
            ])
          })
        ])
      )
    })

    test('only shows shine view for new badges', () => {
      const { queryByTestId: queryNew } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )
      expect(queryNew('shine-view')).toBeTruthy()

      const { queryByTestId: queryOld } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )
      expect(queryOld('shine-view')).toBeFalsy()
    })
  })

  describe('Badge Metadata Integration', () => {
    test('calls getBadgeMetadata with correct badge type', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      
      render(<BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />)

      expect(getBadgeMetadata).toHaveBeenCalledWith('daily_steps')
    })

    test('uses metadata name when available', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('2023-12-01 ‰ªäÊó•„ÅÆÊ≠©Êï∞')).toBeTruthy()
    })

    test('uses metadata icon when available', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('üëü')).toBeTruthy()
    })

    test('falls back to type name when metadata name is not available', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      getBadgeMetadata.mockReturnValueOnce({ icon: 'üèÖ' }) // missing name

      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="custom_badge" isNew={false} />
      )

      expect(getByText('2023-12-01 custom_badge')).toBeTruthy()
    })

    test('falls back to default icon when metadata icon is not available', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      getBadgeMetadata.mockReturnValueOnce({ name: 'Custom Badge' }) // missing icon

      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="custom_badge" isNew={false} />
      )

      expect(getByText('üèÖ')).toBeTruthy() // fallback icon
    })
  })

  describe('Props Handling', () => {
    test('handles default isNew value correctly', () => {
      const { queryByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" />
      )

      expect(queryByText('Êñ∞ÁùÄ')).toBeFalsy()
      expect(queryByText('üåü')).toBeFalsy()
    })

    test('handles empty date string', () => {
      const { getByText } = render(
        <BadgeItem date="" type="daily_steps" isNew={false} />
      )

      expect(getByText(' ‰ªäÊó•„ÅÆÊ≠©Êï∞')).toBeTruthy()
    })

    test('handles empty type string', () => {
      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="" isNew={false} />
      )

      expect(getByText('2023-12-01 ')).toBeTruthy()
      expect(getByText('üèÖ')).toBeTruthy() // fallback icon
    })
  })

  describe('Styling and Layout', () => {
    test('applies correct base card styling', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      const card = getByTestId('badge-card')
      expect(card.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            backgroundColor: expect.any(String),
            borderRadius: expect.any(Number),
            padding: expect.any(Number)
          })
        ])
      )
    })

    test('applies additional styling for new badges', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const card = getByTestId('badge-card')
      expect(card.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            borderWidth: expect.any(Number),
            shadowOpacity: expect.any(Number)
          })
        ])
      )
    })

    test('positions shine effect correctly', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const shineView = getByTestId('shine-view')
      expect(shineView.props.style).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            position: 'absolute',
            width: expect.any(Number),
            height: '100%'
          })
        ])
      )
    })
  })

  describe('Accessibility', () => {
    test('provides accessible label for regular badge', () => {
      const { getByLabelText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByLabelText('‰ªäÊó•„ÅÆÊ≠©Êï∞„Éê„ÉÉ„Ç∏„ÄÅ2023Âπ¥12Êúà1Êó•„Å´Áç≤Âæó')).toBeTruthy()
    })

    test('provides accessible label for new badge', () => {
      const { getByLabelText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      expect(getByLabelText('‰ªäÊó•„ÅÆÊ≠©Êï∞„Éê„ÉÉ„Ç∏„ÄÅ2023Âπ¥12Êúà1Êó•„Å´Áç≤Âæó„ÄÅÊñ∞ÁùÄ')).toBeTruthy()
    })

    test('provides accessible hint for animated elements', () => {
      const { getByTestId } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      const card = getByTestId('badge-card')
      expect(card.props.accessibilityHint).toBe('Êñ∞„Åó„ÅèÁç≤Âæó„Åó„Åü„Éê„ÉÉ„Ç∏„Åß„Åô')
    })
  })

  describe('Performance', () => {
    test('renders quickly with complex animation state', () => {
      const startTime = Date.now()
      
      render(<BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />)
      
      const endTime = Date.now()
      expect(endTime - startTime).toBeLessThan(100)
    })

    test('handles rapid re-renders without memory leaks', () => {
      const { rerender } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      // Simulate rapid updates
      for (let i = 0; i < 10; i++) {
        rerender(
          <BadgeItem 
            date={`2023-12-${String(i + 1).padStart(2, '0')}`} 
            type="daily_steps" 
            isNew={i % 2 === 0} 
          />
        )
      }

      // Should not throw or cause performance issues
      expect(true).toBe(true)
    })
  })

  describe('Edge Cases', () => {
    test('handles null metadata response gracefully', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      getBadgeMetadata.mockReturnValueOnce(null)

      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="invalid_badge" isNew={false} />
      )

      expect(getByText('2023-12-01 invalid_badge')).toBeTruthy()
      expect(getByText('üèÖ')).toBeTruthy() // fallback icon
    })

    test('handles undefined metadata properties', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      getBadgeMetadata.mockReturnValueOnce({}) // empty metadata

      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="empty_badge" isNew={false} />
      )

      expect(getByText('2023-12-01 empty_badge')).toBeTruthy()
      expect(getByText('üèÖ')).toBeTruthy() // fallback icon
    })

    test('handles extremely long badge names', () => {
      const { getBadgeMetadata } = require('../../services/specialBadgeService')
      getBadgeMetadata.mockReturnValueOnce({
        name: '„Åì„Çå„ÅØÈùûÂ∏∏„Å´Èï∑„ÅÑ„Éê„ÉÉ„Ç∏Âêç„Åß„ÉÜ„Ç≠„Çπ„Éà„ÅÆÊäò„ÇäËøî„Åó„Çí„ÉÜ„Çπ„Éà„Åó„Åæ„Åô',
        icon: 'üìù'
      })

      const { getByText } = render(
        <BadgeItem date="2023-12-01" type="long_name_badge" isNew={false} />
      )

      expect(getByText('2023-12-01 „Åì„Çå„ÅØÈùûÂ∏∏„Å´Èï∑„ÅÑ„Éê„ÉÉ„Ç∏Âêç„Åß„ÉÜ„Ç≠„Çπ„Éà„ÅÆÊäò„ÇäËøî„Åó„Çí„ÉÜ„Çπ„Éà„Åó„Åæ„Åô')).toBeTruthy()
    })

    test('handles special characters in date and type', () => {
      const { getByText } = render(
        <BadgeItem date="2023/12/01" type="badge_with_underscore" isNew={false} />
      )

      expect(getByText('2023/12/01 badge_with_underscore')).toBeTruthy()
    })
  })

  describe('Component Updates', () => {
    test('updates animation when isNew prop changes', async () => {
      const { rerender } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      // Clear previous calls
      jest.clearAllMocks()

      rerender(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={true} />
      )

      await waitFor(() => {
        expect(Animated.loop).toHaveBeenCalled()
      })
    })

    test('updates content when type prop changes', () => {
      const { rerender, getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('üëü')).toBeTruthy()

      rerender(
        <BadgeItem date="2023-12-01" type="steps_10k" isNew={false} />
      )

      expect(getByText('üèÉ')).toBeTruthy()
      expect(getByText('2023-12-01 1‰∏áÊ≠©ÈÅîÊàê')).toBeTruthy()
    })

    test('updates date display when date prop changes', () => {
      const { rerender, getByText } = render(
        <BadgeItem date="2023-12-01" type="daily_steps" isNew={false} />
      )

      expect(getByText('2023-12-01 ‰ªäÊó•„ÅÆÊ≠©Êï∞')).toBeTruthy()

      rerender(
        <BadgeItem date="2023-12-02" type="daily_steps" isNew={false} />
      )

      expect(getByText('2023-12-02 ‰ªäÊó•„ÅÆÊ≠©Êï∞')).toBeTruthy()
    })
  })
})
